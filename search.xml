<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL数据库MVCC原理浅析</title>
      <link href="/mysql-shu-ju-ku-mvcc-yuan-li-qian-xi/"/>
      <url>/mysql-shu-ju-ku-mvcc-yuan-li-qian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库MVCC原理浅析概念"><a href="#MySQL数据库MVCC原理浅析概念" class="headerlink" title="MySQL数据库MVCC原理浅析概念"></a>MySQL数据库MVCC原理浅析概念</h2><p><a href="http://mysql.taobao.org/monthly/2017/12/01/" target="_blank" rel="noopener">阿里数据库内核’2017/12’月报</a>中对MySQL数据库MVCC原理浅析的解释是:</p><p>指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p><h2 id="MySQL的三个隐藏列"><a href="#MySQL的三个隐藏列" class="headerlink" title="MySQL的三个隐藏列"></a>MySQL的三个隐藏列</h2><ol><li><p><font color="red">6字节的事务ID(DB_TRX_ID)字段</font>: 用来标识创建本条记录的事务的标识符, 即事务ID。</p></li><li><p><font color="red">7字节的回滚指针(DB_ROLL_PTR)字段</font>: 指向回滚段(rollback segment)的 undo log record (历史版本记录)。</p></li><li><p><font color="red">6字节的行ID(DB_ROW_ID)字段</font>:一个单调递增的行 ID。如果表中没有指定主键或者合适的唯一索引，InnoDB 无法生成聚簇索引时，InnoDB 会以 DB_ROW_ID 字段为主键生成聚簇索引。</p></li></ol><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><ol><li><p>当前读: 读的是最新记录（因为会对需要读取的记录加锁，其它事务不会修改记录，所以保证数据是最新的记录）</p><ul><li>select … lock in share model</li><li>select … for update</li><li>insert</li><li>update</li><li>delete</li></ul></li><li><p>快照读: 读的是存在于 undo log 中对于当前事务可见的历史版本</p><ul><li>不加锁的 select 操作</li></ul></li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><ol><li><p>undo log 是 InnoDB MySQL数据库MVCC原理浅析 事务特性的重要组成部分。当我们对记录做了变更操作时就会产生 undo 记录，undo 记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的表空间。</p></li><li><p>undo log 中记录的是老版本的记录，当一个事务读取数据时，以可见性算法判断当前数据行是否对当前事务可见，如果不可见，则根据当前数据行的 DB_ROLL_PTR 找到下一条数据，继续判断。</p></li></ol><blockquote><p>新增/更新/删除操作数据行时，对应的实际操作</p></blockquote><ul><li><p>新增行：新增一条数据，将 DB_TRX_ID 置为当前事务ID</p></li><li><p>更新行：复制一份本行数据到 undo log，再更新本数据的DB_TRX_ID 置为当前事务ID，DB_ROLL_PTR 字段指向 undo log 中的旧数据（一行数据的历史版本存在于 undo log中，并且以链表的结构存在）</p></li><li><p>删除行：不会直接将数据删除，只是在 <code>record header</code> 中更新删除位（deleted_flag）表示已删除，待purge进程将其真正删除</p></li></ul><h2 id="Read-view"><a href="#Read-view" class="headerlink" title="Read view"></a>Read view</h2><p>InnoDB支持MySQL数据库MVCC原理浅析多版本，其中 RC（Read Committed）和 RR（Repeatable Read）隔离级别是利用 read view（一致读视图）方式支持的。 所谓 read view 就是在<strong>某一时刻</strong>给事务创建 snapshot（快照），把<strong>当时状态（包括活跃读写事务数组）</strong>记下来，之后的所有读操作根据其事务 ID（即trx_id）与 snapshot 中的状态作比较，以此判断数据行对于本事务的可见性。</p><blockquote><p>Read view 中保存的数据结构包括？</p></blockquote><ul><li><p>low_limit_id：当前活跃读写事务数组的最大值 +1（也就是创建快照时刻的下一个未开启的事务ID）</p></li><li><p>up_limit_id：当前活跃读写事务数组的最小值</p></li><li><p>rw_trx_ids：当前活跃读写事务数组（数组中是不包含本事务ID 的）</p></li></ul><blockquote><p>RC 和 RR 隔离级别是利用 read view（一致读视图）方式支持的，那么是怎么实现不同的可见性？</p></blockquote><ul><li><p>RC 级别的事务中，每条 select 操作都会创建一个快照。</p></li><li><p>RR 级别的事务中，在 begin/start transaction 之后的第一条 select 操作后创建一个快照。</p><p>这里有一个值得注意的点，对于 RR 来说，对<strong>同一个表或者不同表</strong>进行的<strong>第一次</strong> select 语句建立了该事务的快照. 其它update, delete, insert 语句和快照的建立没有关系。在snapshot建立之后提交的数据，一致性读就读不到，之前提交的数据就可以读到（示例见下面举例中的事务1001和事务1002）。</p></li></ul><h2 id="可见性算法"><a href="#可见性算法" class="headerlink" title="可见性算法"></a>可见性算法</h2><p>设当前数据行的创建事务ID：db_trx_id</p><p>当前事务的 read view：low_limit_id、up_limit_id、rw_trx_ids</p><ol><li><code>db_trx_id &lt; up_limit_id</code>: 当前行数据是在本事务开启之前就提交的，所以对于本事务是可见；</li><li><code>db_trx_id &gt;= low_limit_id</code>: 当前行数据是在本事务开启之后创建的，所以对于本事务是不可见的；</li><li><code>db_trx_id not in (rw_trx_ids)</code>: 当前行数据是本事务创建的，所以对于本事务是可见；</li><li><code>low_limit_id &lt; db_trx_id &lt; up_limit_id</code>: 当前行数据是在本事务开启时，依然活跃的事务创建的，即使此时该事务已经提交，但是对于本事务来说，当前行数据依然是不可见的。此时，要根据当前行数据的 DB_ROLL_PTR 找到历史版本记录，跳到步骤1重新判断。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>当前数据库中的数据信息如下：</p><img src="MySQL数据库MVCC原理浅析.assets/image-20201217100741886.png" alt="image-20201217100741886" style="zoom:50%;"><p>以下示例是 RR 的隔离级别下：</p><img src="MySQL数据库MVCC原理浅析.assets/image-20201217103031462.png" alt="image-20201217103031462" style="zoom:80%;"><p>此时的 undo log 中的结构如下所示：</p><img src="MySQL数据库MVCC原理浅析.assets/image-20201217100544483.png" alt="image-20201217100544483" style="zoom:50%;"><h2 id="RR真的保证了不幻读？"><a href="#RR真的保证了不幻读？" class="headerlink" title="RR真的保证了不幻读？"></a>RR真的保证了不幻读？</h2><p>在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!</p><p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。<br>InnoDB在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!</p><p>证明示例：</p><img src="MySQL数据库MVCC原理浅析.assets/image-20201217110611515.png" alt="image-20201217110611515" style="zoom:60%;"><p>参考链接</p><p><a href="https://www.cnblogs.com/taek/p/6612728.html" target="_blank" rel="noopener">https://www.cnblogs.com/taek/p/6612728.html</a></p><p><a href="https://segmentfault.com/a/1190000012650596" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012650596</a></p><p><a href="https://www.cnblogs.com/digdeep/p/4947694.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4947694.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot应用中利用AOP实现操作日志记录</title>
      <link href="/springboot-ying-yong-zhong-li-yong-aop-shi-xian-cao-zuo-ri-zhi-ji-lu/"/>
      <url>/springboot-ying-yong-zhong-li-yong-aop-shi-xian-cao-zuo-ri-zhi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h4 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h4><p>在SpringBoot应用开发中，记录用户的操作日志是必不可少的，下面介绍一下利用AOP实现操作日志记录。  </p><p>本文使用了Lombok，不懂的同学建议了解一下</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>首先构建一个SpringBoot项目，引入依赖</p><pre><code>&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;!-- 一个工具包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-core&lt;/artifactId&gt;            &lt;version&gt;LATEST&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- aop注解 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.4&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h4 id="定义日志实体"><a href="#定义日志实体" class="headerlink" title="定义日志实体"></a>定义日志实体</h4><p>这里只是列举了一些简单的字段</p><pre><code>@Datapublic class OperationLog {    private Long id;    private String operation;    private Long operatTime;    /**     * 操作结果：0成功；-1失败     */    private Short operatType;    /**     * 异常日志     */    private String exceptionLog;}</code></pre><h4 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h4><p>由于数据库操作并不是本文的重点，所以这里只是模拟数据库的新增操作。</p><pre><code>public interface OperationLogService {    /**     * 新增日志     * @param operationLog     * @return     */    int insert(OperationLog operationLog);}</code></pre><pre><code>@Servicepublic class OperationLogServiceImpl implements OperationLogService {    @Override    public int insert(OperationLog operationLog) {        System.out.println(operationLog);        System.out.println("日志新增成功");        return 1;    }}</code></pre><h4 id="定义日志注解"><a href="#定义日志注解" class="headerlink" title="定义日志注解"></a>定义日志注解</h4><pre><code>@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Log {    String value();}</code></pre><h4 id="切面的实现"><a href="#切面的实现" class="headerlink" title="切面的实现"></a>切面的实现</h4><pre><code>@Aspect@Componentpublic class LogAspect {    @Autowired    private OperationLogService operationLogService;    @Pointcut(value = "@annotation(com.smile2coder.springboot.aspect.Log)")    public void pointcut() {    }    @Around(value = "pointcut()")    public Object around(ProceedingJoinPoint pjp) throws Throwable {        long start = System.currentTimeMillis();        Object proceed;        try {            proceed = pjp.proceed();        } catch (Throwable throwable) {            save(pjp, start, throwable);            throw throwable;        }        save(pjp, start, null);        return proceed;    }    private void save(ProceedingJoinPoint pjp, long start, Throwable throwable) {        MethodSignature signature = (MethodSignature) pjp.getSignature();        Method method = signature.getMethod();        try {            Log annotation = method.getAnnotation(Log.class);            String operation = annotation.value();            OperationLog operationLog = new OperationLog();            operationLog.setId(1L);            operationLog.setOperation(operation);            operationLog.setOperatTime(System.currentTimeMillis() - start);            if (throwable == null) {                operationLog.setOperatType((short)0);            }else {                operationLog.setOperatType((short)-1);                //如果有异常，保存堆栈信息                  operationLog.setExceptionLog(ExceptionUtil.stacktraceToString(throwable, 999));            }            this.operationLogService.insert(operationLog);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h4 id="控制层的应用"><a href="#控制层的应用" class="headerlink" title="控制层的应用"></a>控制层的应用</h4><pre><code>@RestControllerpublic class TestController {    @RequestMapping("/test")    @Log(value = "这是一个测试接口")    public String test() {//        int i = 1/0;        return "success";    }}</code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>正常结果:</p><pre><code>OperationLog(id=1, operation=这是一个测试接口, operatTime=21, operatType=0, exceptionLog=null)日志新增成功</code></pre><p>异常结果:</p><pre><code>OperationLog(id=1, operation=这是一个测试接口, operatTime=10, operatType=-1, exceptionLog=java.lang.ArithmeticException: / by zero    at com.smile2coder.springboot.controller.TestController.test(TestController.java:18)    at com.smile2coder.springboot.controller.TestController$$FastClassBySpringCGLIB$$d515e671.invoke(&lt;generated&gt;)    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)    at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)    at com.smile2coder.springboot.aspect.LogAspect.around(LogAspect.java:39)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.r)日志新增成功</code></pre><p>本文中有什么错误，请联系我修改，十分感谢</p><p>本文的代码在<a href="https://github.com/smile2coder/springboot-collection" target="_blank" rel="noopener">这里</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> 记录日志 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok-你的开发利器</title>
      <link href="/lombok-ni-de-kai-fa-li-qi/"/>
      <url>/lombok-ni-de-kai-fa-li-qi/</url>
      
        <content type="html"><![CDATA[<p>本文的代码在<a href="https://github.com/smile2coder/springboot-collection" target="_blank" rel="noopener">这里</a>，希望收到一个star，感谢支持</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而为您的Java增光添彩。 永远不要再写另一个getter或equals方法，带有一个注释的您的类有一个功能全面的生成器，自动化您的日志记录变量等等。但是Lombok在使用过程中也有许多值得注意的点，如果不清楚的话，可能会给代码调试带来意想不到的后果！！！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从<a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a>的官网中可以了解到，目前Lombok插件支持Eclipse，MyEclipse，IntelliJ IDEA, Netbeans等主流开发工具。当然，我们也可以在开发工具中直接获取该插件。 </p><h2 id="引入依赖（Maven）"><a href="#引入依赖（Maven）" class="headerlink" title="引入依赖（Maven）"></a>引入依赖（Maven）</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h2 id="这个要怎么玩"><a href="#这个要怎么玩" class="headerlink" title="这个要怎么玩"></a>这个要怎么玩</h2><p>重点来了，这么好的工具要怎么用？且听我慢慢道来…</p><h4 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter/@Setter"></a>@Getter/@Setter</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@Getter/@Setter可以修饰在成员变量和类上。修饰在成员变量上时，会生成该变量的getter()和setter()方法；修饰在类上时，会生成该类中所有的非静态成员变量生成getter()和setter()方法。我们还可以为getter()和setter()方法设置访问级别。当然我们需要的就是public级别，而这个也恰好是默认的。</p><pre><code>@Getter//@Setter(value = AccessLevel.PROTECTED)@Setterpublic class GetterSetterDemo {    String name;    int age;}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class GetterSetterDemo {    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre><h4 id="NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a href="#NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor"></a>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>这三个注解都是类注解。      @NoArgsConstructor会生成一个无参构造器。值得注意的是，在Java中类没有构造器，会默认生成一个无参构造器，那么@NoArgsConstructor还有什么作用呢？这个后续会解释道。</p><pre><code>@NoArgsConstructorpublic class NoArgsConstructorDemo {}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class NoArgsConstructorDemo {}</code></pre><p>@RequiredArgsConstructor会生成一个带参构造器，这个参数包括final或者@NonNull修饰的成员变量。<strong>值得注意的是，如果@NonNull修饰的参数为null时，会在构造器中抛出NullPointerException异常。</strong></p><pre><code>@RequiredArgsConstructorpublic class RequiredArgsConstructorDemo {    private final String name;    private int age;    @NonNull private String house;    public static void main(String[] args) {        RequiredArgsConstructorDemo requiredArgsConstructorDemo = new RequiredArgsConstructorDemo("smile2coder", "big house");    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class RequiredArgsConstructorDemo {    private final String name;    private int age;    private String house;    public RequiredArgsConstructorDemo(String name, String house) {        if (house == null) {            throw new NullPointerException("house is marked non-null but is null");        }        this.name = name;        this.house = house;    }    public static void main(String[] args) {        RequiredArgsConstructorDemo requiredArgsConstructorDemo = new RequiredArgsConstructorDemo("smile2coder", "big house");    }}</code></pre><p>@AllArgsConstructor会生成一个全参的构造器</p><pre><code>@AllArgsConstructorpublic class AllArgsConstructorDemo {    private String name;    private int age;}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class AllArgsConstructorDemo {    private String name;    private int age;    public AllArgsConstructorDemo(String name, int age) {        this.name = name;        this.age = age;    }}</code></pre><p>有个点需要注意，使用@RequiredArgsConstructor和@AllArgsConstructor生成构造器，则不会再生成默认的无参构造器。而在许多框架中需要用到无参构造器，这时就需要配合@NoArgsConstructor使用啦。</p><p>使用这三个注解还可以生成静态工厂类</p><pre><code>@RequiredArgsConstructor(staticName = "of")public class StaticNameDemo {    private final String name;    private int age;    public static void main(String[] args) {        StaticNameDemo smile2coder = StaticNameDemo.of("smile2coder");    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class StaticNameDemo {    private final String name;    private int age;    public StaticNameDemo(String name) {        this.name = name;    }    public static StaticNameDemo of(String name) {        return new StaticNameDemo(name);    }    public static void main(String[] args) {        StaticNameDemo smile2coder = StaticNameDemo.of("smile2coder");    }}</code></pre><h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@Data恐怕是我们用到最多的啦，那么它的作用是什么呢？当@Data修饰在类上时，相当于@Getter, @Setter, @ToString, @EqualsAndHashCode和@RequiredArgsConstructor的功能联合体。让我们简单中寻找更简单的方式。</p><h4 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>构建者模式，一种一步步构建复杂类的设计模式。当不用Lombok时，我们来看一下怎么写</p><pre><code>public class BuilderDemo {    private String name;    private int age;    public BuilderDemo(String name, int age) {        this.name = name;        this.age = age;    }    public static BuilderDemoBuilder builder() {        return new BuilderDemoBuilder();    }    public static class BuilderDemoBuilder {        private String name;        private int age;        public BuilderDemoBuilder name(String name) {            this.name = name;            return this;        }        public BuilderDemoBuilder age(int age) {            this.age = age;            return this;        }        public BuilderDemo build() {            return new BuilderDemo(name, age);        }    }    public static void main(String[] args) {        BuilderDemo smile2coder = BuilderDemo.builder().name("smile2coder").age(11).build();        System.out.println(smile2coder);    }}</code></pre><p>这还不是一个复杂的类，写起来都这么复杂了…如果是一个复杂的类，保守估计都要2根头发的代价。我们来看一下Lombok怎么写</p><pre><code>@Builderpublic class BuilderDemo {    private String name;    private int age;    public static void main(String[] args) {        BuilderDemo smile2coder = BuilderDemo.builder().name("smile2coder").age(11).build();    }}</code></pre><p><strong>世界都安静了…</strong></p><h4 id="Log"><a href="#Log" class="headerlink" title="@Log"></a>@Log</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@Log注解也是我比较常用的。日志是常见的开发手段，没有日志的代码是没有灵魂的。<br>让我们来看看以前是怎么写的</p><pre><code>public class LogDemo {    private static Logger log = LoggerFactory.getLogger(LogDemo.class);    public static void main(String[] args) {        log.info("smile2coder");    }}</code></pre><p>有人说这不是很简单吗？看一下Lombok再说吧</p><pre><code>@Logpublic class LogDemo {    public static void main(String[] args) {        log.info("smile2coder");    }}</code></pre><h4 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a>@Cleanup</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@Cleanup可以用来确保在代码执行路径退出当前作用域之前自动清除给定的资源。默认情况下，退出当前作用域前会调用资源的close()方法，当然，你也可以指定一个无参方法。<br><strong>值得注意的是，当close()方法中包含参数的话，此方法不会被自动调用</strong></p><pre><code>public class CleanupDemo {    public static void main(String[] args) throws IOException {        @Cleanup InputStream inputStream = new FileInputStream(new File("/home/smile2coder"));        //指定一个无参方法        @Cleanup("clean") CleanupDemo cleanupDemo = new CleanupDemo();    }    public void clean() {        System.out.println("clean");    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的，是不是简单了很多</p><pre><code>public class CleanupDemo {    public static void main(String[] args) throws IOException {        InputStream inputStream = null;        try {            inputStream = new FileInputStream(new File("/home/smile2coder"));        } finally {            if(inputStream != null) {                inputStream.close();            }        }        CleanupDemo cleanupDemo = null;        try {            cleanupDemo = new CleanupDemo();        } finally {            if(cleanupDemo != null) {                cleanupDemo.clean();            }        }    }    public void clean() {        System.out.println("clean");    }}</code></pre><h4 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@NonNull可以在方法的参数和构造器的参数上为你生成一个“空值”判断代码块。在方法中，代码块将会插入在方法顶部；在构造器中，代码块将会在任何显式this()或者 super()方法调用后插入。<br><strong>值得注意的是，当方法中已经有“空值”判断代码块，@NonNull不会再生成代码。</strong></p><pre><code>public class NonNullDemo {    @NonNull private String name;    public NonNullDemo(@NonNull String name) {        this.name = name;    }    public void demo(@NonNull String str) {        this.demo(str, "smile2coder");    }    public void demo(@NonNull String str1, String str2) {        System.out.println(str1 + " " + str2);    }    public static void main(String[] args) {        NonNullDemo nonNullDemo = new NonNullDemo("smile2coder");//        nonNullDemo.demo("hello");        nonNullDemo.demo(null);    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class NonNullDemo {    @NonNull private String name;    public NonNullDemo(@NonNull String name) {        if (name == null) {            throw new NullPointerException("name is marked non-null but is null");        }        this.name = name;    }    public void demo(String str) {        this.demo(str, "smile2coder");        if(str == null) {            throw new NullPointerException("str is marked non-null but is null");        }    }    public void demo(String str1, String str2) {        System.out.println(str1 + " " + str2);    }    public static void main(String[] args) {        NonNullDemo nonNullDemo = new NonNullDemo("smile2coder");//        nonNullDemo.demo("hello");        nonNullDemo.demo(null);    }}</code></pre><h4 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@ToString会为类生成toString()方法。默认情况下，它会打印类的名，成员变量。每个成员变量以“,”分隔。当然，你也可以用以下参数定制打印变量。  </p><ul><li>boolean includeFieldNames() default true:是否打印变量</li><li>String[] exclude() default {}:不打印的变量列表</li><li>String[] of() default {}:打印的变量列表</li><li>boolean callSuper() default false:是否调用父类toString()方法</li><li>boolean doNotUseGetters() default false:打印是否调用Getter()方法</li><li>boolean onlyExplicitlyIncluded() default false:默认打印非静态变量；当设置为true时，不再自动包含非静态变量</li></ul><p>我们还可以用注解的方式定制</p><ul><li>@ToString.Exclude:修饰在成员变量，表示不包含该变量</li><li>@ToString.Include:修饰在成员变量，表示包含该变量（这是默认的）</li></ul><pre><code>@ToStringpublic class ToStringDemo {    private String name;    private int age;    @ToString    static class ExcludeDemo {        @ToString.Exclude private String name;        private int age;    }    @ToString(exclude = {"name"})    static class ExcludeArrayDemo {        private String name;        private int age;    }    @ToString    static class IncludeDemo {        @ToString.Include private String name;        private int age;    }    @ToString(of = {"name"})    static class OfDemo {        private String name;        private int age;    }    @ToString(includeFieldNames = false)    static class IncludeFieldNamesDemo {        private String name;        private int age;    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class ToStringDemo {    private String name;    private int age;    @Override    public String toString() {        return "ToStringDemo(" +                "name='" + name + '\'' +                ", age=" + age +                ')';    }    static class ExcludeDemo {        private String name;        private int age;        @Override        public String toString() {            return "ToStringDemo.ExcludeDemo(" +                    "age=" + age +                    ')';        }    }    static class ExcludeArrayDemo {        private String name;        private int age;        @Override        public String toString() {            return "ToStringDemo.ExcludeDemo(" +                    "age=" + age +                    ')';        }    }    static class IncludeDemo {        private String name;        private int age;        @Override        public String toString() {            return "ToStringDemo.IncludeDemo(" +                    "name='" + name + '\'' +                    ", age=" + age +                    ')';        }    }    static class OfDemo {        private String name;        private int age;        @Override        public String toString() {            return "ToStringDemo.OfDemo(" +                    "name='" + name + '\'' +                    ')';        }    }    static class IncludeFieldNamesDemo {        private String name;        private int age;        @Override        public String toString() {            return "ToStringDemo.IncludeFieldNamesDemo()";        }    }}</code></pre><h4 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@EqualsAndHashCode会为类生成equals()和hashCode()方法。用法和@ToString类似</p><pre><code>@EqualsAndHashCodepublic class EqualsAndHashCodeDemo {    private String name;    private int age;}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class EqualsAndHashCodeDemo {    private String name;    private int age;    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (!(o instanceof EqualsAndHashCodeDemo)) return false;        EqualsAndHashCodeDemo that = (EqualsAndHashCodeDemo) o;        return age == that.age &amp;&amp;                Objects.equals(name, that.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age);    }}</code></pre><h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@Value是@Data的不可变形式；默认情况下，所有变量都设为私有和最终字段，并且不会生成setters。默认情况下，该类本身也将最终确定为final，因为不可改变性不能强加于子类。像@Data一样，还会生成有用的toString（），equals（）和hashCode（）方法，每个字段都有一个getter方法，并且还会生成一个覆盖每个参数的构造函数（除了在字段声明中初始化的最终字段之外） 。</p><h4 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@SneakyThrows可用于偷偷地抛出已检查的异常，而无需在方法的throws子句中实际声明。<strong>值得注意的是，不建议使用</strong></p><pre><code>public class SneakyThrowsDemo {    @SneakyThrows(UnsupportedEncodingException.class)    public String utf8ToString(byte[] bytes) {        return new String(bytes, "UTF-8");    }    @SneakyThrows    public void run() {        throw new Throwable();    }}</code></pre><pre><code>public class SneakyThrowsDemo {    public String utf8ToString(byte[] bytes) {        try {            return new String(bytes, "UTF-8");        } catch (UnsupportedEncodingException e) {            throw Lombok.sneakyThrow(e);        }    }    public void run() {        try {            throw new Throwable();        } catch (Throwable t) {            throw Lombok.sneakyThrow(t);        }    }}</code></pre><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>@Synchronized是同步方法修饰符的更安全的变体。与同步一样，注释只能在静态和实例方法上使用。它的操作类似于synced关键字，但是它锁定在不同的对象上。关键字对此进行了锁定，但注解锁定了一个名为$ lock的私有字段。 如果该字段不存在，则会为您创建。如果注释静态方法，则注释将锁定在名为$ LOCK的静态字段上。当然，你也可以指定锁。</p><pre><code>public class SynchronizedDemo {    private final Object readLock = new Object();    @Synchronized    public static void hello() {        System.out.println("smile2coder");    }    @Synchronized    public int answerToLife() {        return 42;    }    @Synchronized("readLock")    public void foo() {        System.out.println("smile2coder");    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class SynchronizedDemo {    private static final Object $LOCK = new Object[0];    private final Object $lock = new Object[0];    private final Object readLock = new Object();    public static void hello() {        synchronized($LOCK) {            System.out.println("smile2coder");        }    }    public int answerToLife() {        synchronized($lock) {            return 42;        }    }    public void foo() {        synchronized(readLock) {            System.out.println("smile2coder");        }    }}</code></pre><h4 id="val"><a href="#val" class="headerlink" title="val"></a>val</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以使用val作为本地变量的类型来代替该变量的真正的类型，该本地变量也会被修饰为final。val只能用在本地变量和循环遍历中的变量。 <strong>值得注意的是，val不能在NetBeans中正确的使用。</strong></p><pre><code>public class ValDemo {    public void demo() {        val string = "hello springboot";        System.out.println(string);        val list = new ArrayList&lt;String&gt;();        list.add("smile2coder");        list.forEach(e -&gt; {            System.out.println(e);        });        val map = new HashMap&lt;String, String&gt;();        map.put("smile2coder", "hello springboot");        System.out.println(map.get("smile2coder"));    }}</code></pre><p>以上Lombok写法，和下面的写法是等价的</p><pre><code>public class ValDemo {    public void demo() {        final String string = "hello springboot";        System.out.println(string);        final List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add("smile2coder");        list.forEach(e -&gt; {            System.out.println(e);        });        final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put("smile2coder", "hello springboot");        System.out.println(map.get("smile2coder"));    }}</code></pre><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var的用法和val的用法基本一致，除了变量不会被修饰为final。<br><strong>值得注意的是，虽然变量不会被修饰为final，但是已经确定的类型是不会再改变的。</strong> 例如</p><pre><code>var x = "smile2coder"; x = 1; //x已经确定为java.lang.String类型，当x再被赋值为int类型时，编译器会提示错误</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Lombok的全部内容，相信使用后会大大提高编码效率，目前许多优秀的开源软件都在使用，还等什么呢。<br>初来乍到，请多指教，本文中有什么错误，请联系我修改，十分感谢</p><p>本文的代码在<a href="https://github.com/smile2coder/springboot-collection" target="_blank" rel="noopener">这里</a>，希望收到一个star，感谢支持</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
